# 開発における教訓とトラブルシューティング (Lessons Learned)

## 2026-02-02: 2025年シミュレーション実装時のトラブル

### 1. Pandas `groupby` の挙動に関する誤解
*   **事象**: `df.groupby(level=0)` を使用した際、インデックスがユニークなID（`race_id`）だと思い込んでいたが、実際には`race_id`がインデックスに設定されていなかった、あるいは意図しないインデックス構造になっており、全行が個別のグループとして処理されてしまった。
*   **教訓**: `groupby` を使用する際は、インデックス(`level=...`)に頼らず、**明示的にカラム名(`by='race_id'`)を指定する**方が安全で可読性も高い。
*   **対策**: `df.groupby('race_id')` のようにカラム名を指定する。

### 2. Pandas データ型 (`dtypes`) の厳密な管理
*   **事象**: `model.predict` にデータを渡す際、一部のカラム（`枠番`, `馬番`など）が `object` 型のまま渡され、モデル（特にscikit-learn/LightGBM系）がエラー `pandas dtypes must be int, float or bool` を吐いた。
*   **原因**: データロード時やマージ時に型が `object` に推論されていた。また、前処理での型変換が漏れていた。
*   **教訓**: 予測直前（Just-In-Time）に、特徴量カラムに対して**強制的に数値変換を行う処理**を挟むのが最も確実である。
*   **対策**:
    ```python
    # 予測直前の安全策
    X = df[features].apply(pd.to_numeric, errors='coerce').fillna(0)
    preds = model.predict(X)
    ```

### 3. カラム名のタイポと空白文字
*   **事象**: `race_data['馬 番']` というように、カラム名に余計なスペースが含まれているコードが存在し、`KeyError` を引き起こした（エラーハンドリングで握りつぶされていたため発見が遅れた）。
*   **教訓**: 日本語カラム名は視認しづらいため、コピー＆ペーストを行うか、`df.columns` をプリントして確認する。また、エラーハンドリング (`try-except`) は、**開発中は具体的にエラー内容を標準出力/ログに出す**ようにする。
*   **対策**: `print(e)` だけでなく `traceback.print_exc()` を使う。カラム名は定数管理を検討する。

### 4. ログ出力の重要性
*   **事象**: スクリプトがエラーなく終了しているのに何も出力されない、あるいは結果が0になるケースがあった。
*   **教訓**:
    *   標準出力(`print`)はバッファリングされることがあるため、即時確認が必要な場合は `sys.stdout.flush()` するか `python -u` オプションを使用する。
    *   重要な分岐（ループの開始、予測の実行、的中判定のTrue分岐など）には必ずログを入れる。

## 2026-02-03: CI(GitHub Actions) の Lint エラー対応

### 1. IndentationError (構文エラー) の罠
*   **事象**: クラスの定義が欠落したまま `@staticmethod` だけが記載されたファイル (`shutuba_method.py`) が存在し、CI が即座に停止した。
*   **原因**: 断片的なコードを別ファイルに疎結合化する際、インデントとクラス階層の不整合が発生していた。
*   **教訓**: ファイルを分割、または新規作成する際は、単独で実行（あるいは `flake8` でチェック）して、基本的な構文チェックを通ることを確認すべき。

### 2. 未使用の global 宣言と F824
*   **事象**: `app.py` などの大規模ファイルで、値を変更しないにもかかわらず `global var` を使っていたため、`flake8` の `F824` でビルドが通らなかった。
*   **教訓**: グローバル変数を**参照するだけ**なら `global` キーワードは不要（代入する場合のみ必要）。不要な `global` は Lint エラーの原因になるため削除する。

### 3. 未定義変数 (F821) と PyTorch の条件付きインポート
*   **事象**: `modules/training.py` で PyTorch を `try-except` でインポートしていたが、失敗時の `nn` や `optim` の定義が漏れていたため、特定の条件下で未定義エラーが発生した。
*   **教訓**: 条件付きインポートを行う場合は、利用される可能性のあるサブモジュール（`nn`, `optim`, `DataLoader` 等）も `None` で初期化するなどの対応が必要。


## 2026-02-05: 大規模データ（2010-2024）によるモデル刷新時の教訓

### 1. シミュレーション時のデータリーク（Data Leak）の罠
*   **事象**: 過去データのシミュレーション（バックテスト）を実施した際、的中率が70%超、回収率が1400%という非現実的な数値が出た。
*   **原因**: 特徴量エンジニアリング（`add_horse_history_features`）において、予測対象のレースの日付と馬成績データの日付が完全に一致しない場合（秒単位のズレなど）、不一致とみなされて「予測モード（本番用ロジック）」が発動していた。このモードでは対象の馬の「全期間の平均成績」を計算するため、**未来の成績（そのレースの結果自体）**が特徴量に含まれてしまっていた。
*   **教訓**: バックテストやシミュレーションを行う際は、**日付の型と精度（時刻なしの日付のみに正規化するなど）を厳密に一致させる**必要がある。また、異常な高い数値が出た場合は、真っ先にデータリーク（Leakage）を疑うこと。
*   **対策**:
    ```python
    # 日付を00:00:00に揃える
    df['date'] = pd.to_datetime(df['date']).dt.normalize()
    hr['date'] = pd.to_datetime(hr['date']).dt.normalize()
    ```

### 2. インデックス形式とカラム欠落
*   **事象**: `results.pickle` に `date` カラムが含まれておらず、学習スクリプトでフィルタリングが失敗した。
*   **原因**: 大量のスクレイピングデータを `pd.concat` で結合する際、元のデータフレームが空だったりインデックス形式が異なると、カラムの結合が意図通りに行われないことがある。また、スクレイピング時に `title` から日付を抽出する処理が失敗している期間があった。
*   **教訓**: 保存されたデータの整合性を定期的にチェックするスクリプト（`check_data_integrity.py`）を運用し、重要なカラム（`date`, `horse_id` など）の欠損率を監視する。
*   **対策**: `results.index.astype(str).str[:4]` のように、インデックス（Race ID）から年度を抽出して代替フィルタリングを行うロジックをフォールバックとして用意する。
